{
"metadata":{
	"_id": "aDy3s2DcS-6vnViKw3cn2w",
	"changelog": [
	],
	"dependencies": [
	],
	"description": "Data Replication",
	"key": "sys.replication",
	"major_version": 0,
	"manifest": {
		"BusinessObjectDef": {
			"IfUW4bRlQKqbgXK7cl3J0w": "sys-pkg:2",
			"__tB83WrT66MY3e6kzLhIg": "sys-pkg:2",
			"lrxsMjzuSUm94GgkKB4IuA": "sys-pkg:2",
			"oRGn2pdYQlqhT0kMQoXq_w": "sys-pkg:1"
		},
		"CodeModule": {
			"Xq8Q2owMSUiZSCbylcO-Xg": "sys-pkg:7"
		},
		"Config": {
			"7rDu5_DYQv6-XtxHzgFOhQ": "sys-pkg:2",
			"8fvqb7b8TZCElDHF8tK_dg": "sys-pkg:2",
			"9HAsXWmwSLmIqkJGi--rIA": "sys-pkg:1",
			"RutGGmgLRGSYunvpy_T5Ag": "sys-pkg:3"
		},
		"DataTrigger": {
			"7DCC2yA_TFS5_2AGfBb8IQ": "sys-pkg:2",
			"W_9KGyxhRfCYK7C-qWOpUw": "sys-pkg:1"
		},
		"LabelGroup": {
			"FHHQSdnRTa6KYVGhOjJyxw": "sys-pkg:1",
			"eQUDDFU3TaqLokpHUFdawQ": "sys-pkg:1",
			"jIFhT3dDTDWj5L75KbfMYQ": "sys-pkg:2",
			"mqhspCUISEKJhrBpiShT7g": "sys-pkg:1"
		},
		"Role": {
			"waXPuuXVSEat6D7hXR0Nng": "sys-pkg:1"
		},
		"WebService": {
			"JAwvZBtTSRGyXJjgriiQkw": "sys-pkg:4",
			"a2OXNjw-Rqqxfl6atKlEvw": "sys-pkg:7",
			"aoqZKRO8TkmfIZeuj77GHA": "sys-pkg:1",
			"be2qDJ7DT1qkgJDEr9jttg": "sys-pkg:3",
			"p1Hh0VyER7eLn1vfv5UFBQ": "sys-pkg:1",
			"wW66tKohQdahn01dGX7PBA": "sys-pkg:1"
		}
	},
	"minor_version": 13,
	"name": "Replication",
	"version": "0.13.0"
},
"business_objects":[
{
	"__disp": "ReplicationSpec",
	"__ver": "sys-pkg:2",
	"_class": "BusinessObjectDef",
	"_id": "IfUW4bRlQKqbgXK7cl3J0w",
	"abstract": false,
	"class_name": "ReplicationSpec",
	"definition": {
		"allow_two_way": {
			"type": "boolean"
		},
		"business_object": {
			"ref_class": "BusinessObjectDef",
			"type": "reference"
		},
		"condition": {
			"type": "object"
		},
		"data_trigger": {
			"ref_class": "DataTrigger",
			"type": "reference"
		},
		"partner": {
			"ref_class": "ReplicationPartner",
			"type": "reference"
		}
	},
	"superclass": null,
	"system": true
},
{
	"__disp": "MergeCheck",
	"__ver": "sys-pkg:2",
	"_class": "BusinessObjectDef",
	"_id": "__tB83WrT66MY3e6kzLhIg",
	"abstract": false,
	"class_name": "MergeCheck",
	"definition": {
		"created_date": {
			"type": "datetime"
		},
		"fields": {
			"type": "object"
		},
		"object_class": {
			"type": "string"
		},
		"object_id": {
			"type": "string"
		}
	},
	"doc": "One of these are created when divergent versions of an object emerge from being modified independently on two different instances.  Automatic merging occurs, but this object retains any data that may have been overwritten by the merge, so it can be reviewed manually.",
	"system": false
},
{
	"__disp": "PendingReplication",
	"__ver": "sys-pkg:2",
	"_class": "BusinessObjectDef",
	"_id": "lrxsMjzuSUm94GgkKB4IuA",
	"abstract": false,
	"class_name": "PendingReplication",
	"definition": {
		"attempt_result": {
			"type": "object"
		},
		"created_date": {
			"type": "datetime"
		},
		"spec": {
			"ref_class": "ReplicationSpec",
			"type": "reference"
		},
		"status": {
			"enum": [
				"new",
				"in_progress",
				"error"
			],
			"type": "string"
		},
		"target_object": {
			"type": "object"
		},
		"target_version": {
			"type": "string"
		},
		"update_type": {
			"enum": [
				"create",
				"update",
				"delete"
			],
			"type": "string"
		}
	},
	"system": true
},
{
	"__ver": "sys-pkg:1",
	"_class": "BusinessObjectDef",
	"_id": "oRGn2pdYQlqhT0kMQoXq_w",
	"class_name": "ReplicationPartner",
	"definition": {
		"auth": {
			"type": "object"
		},
		"name": {
			"type": "string"
		},
		"url": {
			"type": "url"
		}
	},
	"system": true
},
{
	"__ver": "sys-pkg:7",
	"_class": "CodeModule",
	"_id": "Xq8Q2owMSUiZSCbylcO-Xg",
	"code": "function (db, httpRequestLib, _, Q) {\n    var PR_THROTTLE_PERIOD = 500; //throttle PendingReplication processing to \n    var exports = {};\n    var inProgress = {};\n    var removeInProgress = function(key) {\n        delete inProgress[key];\n    };\n    \n    var running = false;\n    \n    const GridFsService = db._svc.GridFsService;\n    const fs = require('fs');\n    const sendAttachment = function(att, url, header) {\n        const deferred = Q.defer();\n        \n        GridFsService.getFile(att.attachment_id).then(fileResult=>{\n            \n            //pipe to filesystem first to get around quirk in request lib that closes the stream too early\n            const tempFile = '/tmp/'+att.attachment_id;\n            const tempfileStream = fs.createWriteStream(tempFile);\n            fileResult.readstream.pipe(tempfileStream);\n            \n            fileResult.readstream.on('end', function() {\n                const formData = {\n                    fileStream:fs.createReadStream(tempFile)\n                }\n                 \n                httpRequestLib.post( {\n                    uri:url+'?metaObj='+encodeURIComponent(JSON.stringify({attachment:att, metadata:fileResult.metadata})),\n                    headers:header, json:true, formData\n                }, function(err, httpResponse, body) {\n                    deferred.resolve(body);\n                    \n                    if(body && body.result === 'success') {\n                        console.log('Successful replication of attachment %s', att.attachment_id);\n                    }\n                    else {\n                        console.log('FAILED REPLICATION of attachment %s %j', att.attachment_id, body);\n                        err && console.log(err);\n                    }\n                    fs.unlink(tempFile);\n                });\n            });\n            \n        },\n        err=>{\n            console.log('FAILED REPLICATION of attachment %s (missing from filestore)', att.attachment_id);\n            deferred.resolve('missing file');\n        }\n        );\n        \n        return deferred.promise;\n    };\n    \n    const sendAttachments = function(partner, targetBoClassName, pr) {\n        \n        var promiseChain = Q(true);\n        \n        const typeDesc = db[targetBoClassName]._bo_meta_data.type_desc_map;\n        \n        const url = partner.url+'/ws/replication/attachment';\n        const header = { authorization:'Bearer '+partner.auth.token};\n        const targetObj = pr.target_object;\n        \n        \n        _.forEach(typeDesc, (td, fieldName)=>{\n            var attArr = null;\n            if(td instanceof Array && td[0].type === 'attachment') {\n                attArr = targetObj[fieldName];\n            } \n            else if(td.type === 'attachment' && targetObj[fieldName]) {\n                attArr = [targetObj[fieldName]];\n            }\n            if(attArr && attArr.length) {\n                _.forEach(targetObj[fieldName], att=>{\n                    console.log(att);\n                    promiseChain = promiseChain.then(sendAttachment.bind(null, att, url, header));\n                });\n            }\n        });\n        return promiseChain;\n    };\n    \n    /**\n     * Asynchronously enqueue a data-update event to be replicated.\n     **/\n    exports.enqueueEvent = function(modelObj, updateType) {\n        console.log('enqueueing %s for %s', updateType, modelObj._id);\n        \n        //Find all ReplicationSpec's satisfied by modelObj\n        db.ReplicationSpec.find({'business_object._id':modelObj._bo_meta_data.bod_id}).exec().then(function(specList){\n            // console.log('Replication Specs: %j', specList);\n            _.forEach(specList, function(repSpec) {\n                //Check the condition on this repSpec to see if it should be \n                var conditionSatisfied = true;\n                if(repSpec.condition)\n                    conditionSatisfied = modelObj.satisfiesCondition(repSpec.condition);\n                if(conditionSatisfied) {\n                    //This modelObj should be replicated to repSpec.partner!\n                    \n                    var newPrObj = {\n                        target_object:modelObj.toPlainObject ? modelObj.toPlainObject() : modelObj, //if its a delete, modelObj isn't real\n                        update_type:updateType,\n                        spec:repSpec,\n                        status:'new'\n                    };\n                    // console.log(newPrObj);\n                    // console.log('previous: %j', modelObj._previous);\n                    \n                    if(modelObj._previous && modelObj._previous.__ver) {\n                        newPrObj.target_version = modelObj._previous.__ver;\n                    }\n                    \n                    new db.PendingReplication(newPrObj).save().then(function() {}, \n                    function(err) {\n                        console.error('problem saving PendingReplication %j', err);\n                    });\n                }\n            });\n        });\n        \n    };//End enqueueEvent\n    \n    /**\n     * Process queue\n     **/\n    exports.processQueue = function() {\n        if(!running) {\n            console.log(\"PROCESSING REPLICATION QUEUE!\");\n            running = true;\n            \n            var lastPromise = Q(true);\n            var intervalObj;\n            \n            //Called on a periodic to throttle replication processing\n            const processNextPr = function() {\n                if(lastPromise.state === 'pending') {\n                    //Skip this round if still waiting on a previous record\n                    return;\n                }\n                \n                lastPromise = db.PendingReplication.findOne({status:'new'}).then(function(pr) {\n                    if(!pr) {\n                        running = false;\n                        clearInterval(intervalObj);\n                        return;\n                    }\n                    \n                    var targetBoClassName;\n                    \n                    pr.status = 'in_progress';\n                    \n                    //Grab the ReplicationSpec for this PR\n                     return Q.all([\n                        pr.save({skipTriggers:true}, null),\n                        db.ReplicationSpec.findOne({_id:pr.spec._id}).exec()\n                    ])\n                    .then(function(resultArr){\n                        var repSpec = resultArr[1];\n                        targetBoClassName = db[repSpec.business_object._id]._bo_meta_data.class_name;\n                        \n                        //Grab the partner\n                        return db.ReplicationPartner.findOne({_id:repSpec.partner._id}).exec();\n                    })\n                    .then(function(partner) {\n                        //Now, let's send pr.target_object to partner.url using credentials in partner.auth\n                        console.log('sending to %s -> %s', partner.name, pr.target_object._id);\n                        var url = partner.url+'/ws/replication';\n                        var header = { authorization:'Bearer '+partner.auth.token};\n                        \n                        var postBody = {\n                            update_type:pr.update_type, \n                            target_class:targetBoClassName, \n                            target_object:pr.target_object, \n                            target_version:pr.target_version\n                        };\n                        \n                        var deferred = Q.defer();\n                        httpRequestLib.post( {\n                            uri:url,\n                            headers:header,\n                            rejectUnauthorized: false,\n                            json:true,\n                            body:postBody\n                        }, function(err, httpResponse, body) {\n                            if(body && body.result === 'success') {\n                                console.log('Successful replication of %s %s', targetBoClassName, pr.target_object._id);\n                                sendAttachments(partner, targetBoClassName, pr).then(()=>{\n                                    deferred.resolve(pr.remove());  \n                                });\n                            }\n                            else if(!body || body.result !== 'up-to-date') {\n                                console.error('FAILED REPLICATION: %s, %j', err, body);\n                                if(!body) body = {};\n                                body._http_err = err;\n                                pr.attempt_result = body;\n                                pr.status = 'error';\n                                pr.save();\n                            }\n                        });//end httpRequest.post\n                        \n                    });//end \"then\" sequence\n                }); //end PendingReplication.findOne().then(...)\n                \n            };//end processNextPr function def\n            \n            intervalObj = setInterval(processNextPr, PR_THROTTLE_PERIOD);\n            \n        }//end if(!running)\n        \n    };//end processQueue\n    \n    \n    return exports;\n}",
	"name": "ReplicationService",
	"path": "sys/replication"
},
{
	"__ver": "sys-pkg:2",
	"_class": "Config",
	"_id": "7rDu5_DYQv6-XtxHzgFOhQ",
	"allow_customize": false,
	"key": "sys.dbui.perspective.default.ReplicationSpec",
	"rolespec": [
	],
	"system": false,
	"value": {
		"edit": {
			"layout": [
				"business_object",
				[
					"partner",
					"allow_two_way"
				],
				"condition",
				"data_trigger"
			]
		},
		"list": {
			"fields": [
				"business_object",
				"partner",
				"condition"
			]
		},
		"picker_list": {
			"fields": [
				"business_object",
				"partner",
				"condition"
			]
		},
		"view": {
			"layout": [
				"business_object",
				[
					"partner",
					"allow_two_way"
				],
				"condition",
				"data_trigger"
			],
			"recordActions": [
				"edit",
				"delete",
				{
					"icon": "fa-upload",
					"label": "InitialSync",
					"ws": "replication/initialSync"
				}
			]
		}
	}
},
{
	"__ver": "sys-pkg:2",
	"_class": "Config",
	"_id": "8fvqb7b8TZCElDHF8tK_dg",
	"allow_customize": false,
	"key": "sys.dbui.perspective.default.PendingReplication",
	"rolespec": [
	],
	"system": false,
	"value": {
		"edit": {
			"layout": [
				"spec",
				"update_type",
				"target_version",
				"attempt_result",
				"target_object"
			]
		},
		"list": {
			"fields": [
				"spec",
				"update_type",
				"status",
				"attempt_result",
				"created_date"
			]
		},
		"view": {
			"layout": [
				"created_date",
				"spec",
				"update_type",
				"target_version",
				"attempt_result",
				"target_object"
			]
		}
	}
},
{
	"__ver": "sys-pkg:1",
	"_class": "Config",
	"_id": "9HAsXWmwSLmIqkJGi--rIA",
	"key": "sys.dbui.perspective.default.ReplicationPartner",
	"system": false,
	"value": {
		"edit": {
			"layout": [
				"name",
				"url",
				"auth"
			]
		},
		"list": {
			"fields": [
				"name",
				"url"
			]
		},
		"picker_list": {
			"fields": [
				"name",
				"url"
			]
		},
		"view": {
			"layout": [
				"name",
				"url",
				"auth"
			]
		}
	}
},
{
	"__ver": "sys-pkg:3",
	"_class": "Config",
	"_id": "RutGGmgLRGSYunvpy_T5Ag",
	"allow_customize": false,
	"key": "sys.dbui.perspective.default.MergeCheck",
	"rolespec": [
	],
	"system": false,
	"value": {
		"edit": {
			"layout": [
				"object_class",
				"object_id",
				"fields",
				"created_date"
			]
		},
		"list": {
			"fields": [
				"object_class",
				"object_id",
				"created_date"
			]
		}
	}
},
{
	"__ver": "sys-pkg:2",
	"_class": "DataTrigger",
	"_id": "7DCC2yA_TFS5_2AGfBb8IQ",
	"action": "function (db, isCreate, isUpdate, isDelete) {\n\n  if(!this.business_object && !isDelete)\n    throw \"Must specify a business object\";\n\n  var specBo = this;\n  var boClass = specBo.business_object._disp;\n  \n  var promiseToReturn = null;\n\n  if(!isDelete) {\n    //Create the corresponding data trigger if needed...\n    var dataTriggerKey = 'sys.replication.'+boClass; \n    \n    if(this.allow_two_way) {\n        //allow this to trigger when objects are updated via incoming replication\n        dataTriggerKey += '.onReplication';\n    }\n    \n    promiseToReturn = db.DataTrigger.find({key:dataTriggerKey}).exec().then(function(matchingDt) {\n       if(!matchingDt || matchingDt.length === 0) {\n            \n            var newDataTrigger = new db.DataTrigger({\n              key:dataTriggerKey,\n              business_object:specBo.business_object,\n              before_after:'after',\n              on_create:true,\n              on_update:true,\n              on_delete:true,\n              description:'Notify replication service of changes to '+boClass+' (this DataTrigger created automatically)',\n              action:function(ReplicationService, isCreate, isUpdate) {\n                  var updateType = isCreate ? 'create' : (isUpdate ? 'update' : 'delete');\n                  ReplicationService.enqueueEvent(this, updateType);\n                }\n            });\n        \n            //Set reference in this record to point to the new data trigger:\n            return newDataTrigger.save().then(function() {\n              specBo.data_trigger = newDataTrigger;\n            });\n       }\n       else {\n           specBo.data_trigger = matchingDt[0];\n       }\n    });\n    \n    \n  }\n  \n  if(isDelete || (isUpdate && this.data_trigger && (this._previous.business_object._id !== this.business_object._id))) {\n      \n      db.ReplicationSpec.find({_id:{$ne:specBo._id}, 'data_trigger._id':specBo.data_trigger._id}).exec().then(function(otherSpecs) {\n         if(!otherSpecs || otherSpecs.length === 0) {\n             db.DataTrigger.findOne({_id:specBo.data_trigger._id}).exec().then(function(dt) {\n              dt.remove();\n            });\n         } \n      });\n  }\n\n  return promiseToReturn;\n\n}",
	"before_after": "before",
	"business_object": {
		"_disp": "ReplicationSpec",
		"_id": "IfUW4bRlQKqbgXK7cl3J0w"
	},
	"key": "sys.replication.onSpecUpdate",
	"on_create": true,
	"on_delete": true,
	"on_update": true
},
{
	"__ver": "sys-pkg:1",
	"_class": "DataTrigger",
	"_id": "W_9KGyxhRfCYK7C-qWOpUw",
	"action": "function (ReplicationService) {\n    ReplicationService.processQueue();\n}",
	"before_after": "after",
	"business_object": {
		"_disp": "PendingReplication",
		"_id": "lrxsMjzuSUm94GgkKB4IuA"
	},
	"key": "sys.replication.onPendingReplication",
	"on_create": true
},
{
	"__ver": "sys-pkg:1",
	"_class": "LabelGroup",
	"_id": "FHHQSdnRTa6KYVGhOjJyxw",
	"key": "sys.dbui.bo.ReplicationPartner",
	"language": {
		"_disp": "English",
		"_id": "-9vPfv2lEeSFtiimx_V4dw",
		"code": "en"
	},
	"value": {
		"auth": "Authentication",
		"name": "Name",
		"url": "Partner Url"
	}
},
{
	"__ver": "sys-pkg:1",
	"_class": "LabelGroup",
	"_id": "eQUDDFU3TaqLokpHUFdawQ",
	"key": "sys.dbui.bo.MergeCheck",
	"language": {
		"_disp": "English",
		"_id": "-9vPfv2lEeSFtiimx_V4dw",
		"code": "en"
	},
	"system": false,
	"value": {
		"created_date": "Created Date",
		"fields": "Fields",
		"object_class": "Object Class",
		"object_id": "Object Id"
	}
},
{
	"__ver": "sys-pkg:2",
	"_class": "LabelGroup",
	"_id": "jIFhT3dDTDWj5L75KbfMYQ",
	"key": "sys.dbui.bo.ReplicationSpec",
	"language": {
		"_disp": "English",
		"_id": "-9vPfv2lEeSFtiimx_V4dw",
		"code": "en"
	},
	"value": {
		"allow_two_way": "Allow 2-way",
		"business_object": "Business Object",
		"condition": "Condition",
		"data_trigger": "DataTrigger",
		"partner": "Partner"
	}
},
{
	"__ver": "sys-pkg:1",
	"_class": "LabelGroup",
	"_id": "mqhspCUISEKJhrBpiShT7g",
	"key": "sys.dbui.bo.PendingReplication",
	"language": {
		"_disp": "English",
		"_id": "-9vPfv2lEeSFtiimx_V4dw",
		"code": "en"
	},
	"value": {
		"attempt_result": "Attempt Result",
		"spec": "ReplicationSpec",
		"target_object": "Target Object",
		"target_version": "Target Version ID",
		"update_type": "Update Type"
	}
},
{
	"__ver": "sys-pkg:1",
	"_class": "Role",
	"_id": "waXPuuXVSEat6D7hXR0Nng",
	"name": "ROLE_REPLICATOR"
},
{
	"__disp": "/repsync/specialSync",
	"__ver": "sys-pkg:4",
	"_class": "WebService",
	"_id": "JAwvZBtTSRGyXJjgriiQkw",
	"doc": "1) Grab manifest from partner\n2) Query local database.  For each record w/ matching version id, do a dummy save locally.",
	"function": "function (db, queryParams, _, Q, httpRequestLib, nodeRequire, ReplicationService) {\n    var deferred = Q.defer();\n    var partnerName = queryParams.partner;\n    var boClass = queryParams.boClass;\n    \n    var VersionId = nodeRequire('../api/datasource/version_id');\n    \n    var partnerUrl;\n    var token;\n    \n    return db.ReplicationPartner.findOne({name:partnerName}).then(function(rp) {\n        \n      if(!rp) {\n            throw new Error('bad partner name');\n      }\n      \n      partnerUrl = rp.url;\n      token = rp.auth.token;\n      \n      return db.ReplicationSpec.findOne({partner:rp._id, business_object:db[boClass]._bo_meta_data.bod_id})\n    }) \n    .then(function(repSpec) {\n        \n      var specCondition = repSpec.condition;\n\n      var url = partnerUrl+'/ws/repsync/getManifest?boClass='+boClass;\n      var header = { authorization:'Bearer '+token};\n      \n      \n      console.log('Attempting HTTP GET of %s', url);\n      httpRequestLib.get( {\n          uri:url,\n          headers:header,\n          rejectUnauthorized: false,\n          json:true\n      }, function(err, httpResponse, body) {\n          if(body && body.result) {\n              \n              \n              var partnerVersion = {}; //maps _id to __ver\n              \n              _.forEach(body.result, function(item){\n                  partnerVersion[item._id] = new VersionId(item.__ver);\n              });\n              \n              db[boClass].find({}).then(function(resultArr) {\n                  var toSave = [];\n                  \n                    _.forEach(resultArr, function(localObj) {\n                        var id = localObj._id;\n                        var pv = partnerVersion[localObj._id];\n                        var lv = new VersionId(''+localObj.__ver);\n                        \n                        //Compare versions...\n                        if(pv && lv.relationshipTo(pv).same) {\n                            toSave.push(localObj);\n                        }\n                    });\n                    \n                    //finished processing resultArr\n                    deferred.resolve({total:toSave.length});\n                    \n                    var intervalObj;\n                    var index=0;\n                    var saveNext = function() {\n                        if(index >= toSave.length) {\n                            return clearInterval(intervalObj);\n                        }\n                        console.log('saving %s...', toSave[index]._id);\n                        toSave[index].save();\n                        index++;\n                    };\n                    intervalObj = setInterval(saveNext, 500);\n              });\n              \n          }\n          else {\n              console.error('FAILED MANIFEST GET: %s, %j', err, body);\n              deferred.reject('failed manifest get')\n          }\n      });\n    \n    \n    return deferred.promise;\n    \n});\n    \n}",
	"path": "/repsync/specialSync",
	"rolespec": [
		"waXPuuXVSEat6D7hXR0Nng"
	]
},
{
	"__disp": "/replication",
	"__ver": "sys-pkg:7",
	"_class": "WebService",
	"_id": "a2OXNjw-Rqqxfl6atKlEvw",
	"function": "function (db, auth, req, postBody, _, Q, nodeRequire) {\n    \n    if(!postBody || !postBody.update_type || !postBody.target_class || !db[postBody.target_class]) {\n        throw \"invalid request\";\n    }\n    \n    var VersionId = nodeRequire('../api/datasource/version_id');\n    var dataTriggerPattern = '.*onReplication.*';\n    \n    var className = postBody.target_class;\n    var targetObj = postBody.target_object;\n    var targetVer = postBody.target_version;\n    var isDelete = postBody.update_type === 'delete';\n    \n    var TargetModel = db[className];\n    var currPromise = TargetModel.findOne({_id:targetObj._id}).exec();\n    \n    if(!isDelete) {\n        //First, check for existing\n        return Q.all([currPromise, auth.aggregateUpdateDacs(req, TargetModel)])\n        .then(function(resultArr){\n            var currObj = resultArr[0];\n            var dacObj = resultArr[1];\n            \n            if(currObj) {\n                \n                //Check Version\n                var localVerIsOld = typeof currObj.__ver !== 'string'; //(OLD records have object id's as __ver values)\n                \n                var localVersion = !localVerIsOld && new VersionId(currObj.__ver);\n                var incomingVersion = new VersionId(targetObj.__ver);\n                \n                //Compare versions...\n                var localToIncoming = !localVerIsOld && localVersion.relationshipTo(incomingVersion);\n                \n                \n                if(localToIncoming.same) {\n                    return {result:'up-to-date'};\n                }\n                \n                if(localToIncoming.descendant) {\n                    return {result:'skipped - local version newer'};\n                }\n                \n                if(localVerIsOld || localToIncoming.ancestor) {\n                    //local is ancestor of incoming -> incoming is newer; \n                    //insert changes - no merge required\n                    targetObj.__ver = currObj.__ver;\n                \n                    _.assign(currObj, targetObj); \n                \n                    return currObj.save({useVersionId:incomingVersion.toString(),filterTriggers:dataTriggerPattern}, null).then(function(){return {result:'success', action:'updated'}});\n                }\n                \n                if(localToIncoming.cousin) {\n                    //divergent changes - do a merge.\n                    var manualCheck = {};\n                    var tdMap = currObj._bo_meta_data.type_desc_map;\n                    \n                    _.forEach(_.union(Object.keys(currObj), Object.keys(targetObj)), function(f) {\n                        if(f.indexOf('_') === 0) {\n                            return;\n                        }\n                        \n                        var cVal = currObj[f], tVal = targetObj[f];\n                        \n                        if(cVal instanceof Date) {\n                            currObj[f] = cVal = cVal.toISOString(); //dates in targetObj already in ISO string format\n                            \n                        }\n                        \n                        if(cVal == tVal || _.isEqual(cVal, tVal)) {\n                            return;\n                        }\n                        \n                        var td = tdMap[f] || {};\n                        \n                        //Set merged value of currObj[f] \n                        \n                        if(cVal == null && tVal != null) {\n                            currObj[f] = tVal;\n                            return;\n                        }\n                        else if(cVal != null && tVal == null) {\n                            //current has the non-null value; we're good\n                            return;\n                        }\n                        \n                        //if it's a reference, they're equal if _id is equal.\n                        if(td.type === 'reference' && cVal._id === tVal._id) {\n                            return;\n                        }\n                        \n                        //Arrays?\n                        if(td instanceof Array) {\n                            if(cVal.length === 0 && tVal.length !== 0) {\n                                currObj[f] = tVal;\n                                return;\n                            }\n                            else if(cVal.length !== 0 && tVal.length === 0) {\n                                return;\n                            }\n                            var typ = td[0].type;\n                            if(typ === 'reference') {\n                                currObj[f] = _.uniq(cVal.concat(tVal), '_id');\n                                return;\n                            }\n                            if(typ === 'attachment') {\n                                currObj[f] = _.uniq(cVal.concat(tVal), 'attachment_id');\n                                return;\n                            }\n                            //an array of anything other than refs or attachments: just union the two.\n                            currObj[f] = _.union(cVal, tVal);\n                            return;\n                            \n                        }\n                        \n                        //Both are non-null and not equal at this point.\n                        \n                        if(td.type == 'string' || td.type == 'text') {\n                            //if one is already included in the other, use the bigger one:\n                            if(cVal.indexOf(tVal) > -1) {\n                                //tVal is contained in cVal; we're good\n                                return;\n                            }\n                            if(tVal.indexOf(cVal) > -1) {\n                                currObj[f] = tVal;\n                                return;\n                            }\n                            //Concatenate\n                            var connector = (td.type == 'string') ? ' | ' : '\\n\\n';\n                            currObj[f] = cVal + connector + tVal;\n                            return;\n                        }\n                        \n                        //non-null, not equal, and not strings... flag for a manual check\n                        manualCheck[f] = {local:cVal, incoming:tVal};\n                    }) ;\n                    \n                    var mergedVersion = VersionId.merge(localVersion, incomingVersion).toString();\n                    \n                    \n                    if(Object.keys(manualCheck).length > 0) {\n                        var mc = new db.MergeCheck({object_class:className, object_id:targetObj._id, fields:manualCheck});\n                        mc.save();\n                    }\n                    \n                        \n                    return currObj.save({useVersionId:mergedVersion,filterTriggers:dataTriggerPattern}, null).then(function(){return {result:'success', action:'merged'}});\n                }\n                \n                \n                \n            }\n            else {\n                var newObj = new TargetModel(targetObj);\n                return newObj.save({useVersionId:targetObj.__ver,filterTriggers:dataTriggerPattern}, null).then(function(){return {result:'success', action:'created'}});\n            }\n            \n        },\n        function(err) {\n            return {error:'Insufficient privileges'};\n        });\n    }\n    else {\n        return {result:'no deletes yet'};\n    }\n    \n    \n}",
	"path": "/replication",
	"rolespec": [
		"waXPuuXVSEat6D7hXR0Nng"
	]
},
{
	"__ver": "sys-pkg:1",
	"_class": "WebService",
	"_id": "aoqZKRO8TkmfIZeuj77GHA",
	"function": "function (queryParams, db, ReplicationService) {\n    return db.ReplicationSpec.findOne({_id:queryParams.id}).exec().then(function(rs) {\n        var TargetModel = db[rs.business_object._id];\n        var queryObj = rs.condition || {};\n        TargetModel.find(queryObj).then(function(resultList) {\n            if(!resultList || resultList.length === 0) {\n                return {message:'no records to replicate'};\n            }\n            \n            //Nice and slow...\n            var delay = 2000; //2 sec\n            var i=0;\n            \n            var intervalObj = setInterval(function(){\n                ReplicationService.enqueueEvent(resultList[i], 'create');\n                i++;\n                if( i >= resultList.length) {\n                    clearInterval(intervalObj);\n                }\n            }, delay);\n            \n            return {\n                message:'Replicating '+resultList.length+' records - one every '+delay+' millis.'\n            };\n        });\n    });\n}",
	"path": "/replication/initialSync",
	"rolespec": null
},
{
	"__disp": "/repsync/performSync",
	"__ver": "sys-pkg:3",
	"_class": "WebService",
	"_id": "be2qDJ7DT1qkgJDEr9jttg",
	"doc": "Initiate a replication sync w/ partner. For each class of interest:\n1) Grab manifest from partner\n2) Grab local manifest. For each record:\n2.1) compare version id's\n2.2) if partner needs my version, send it to partner's \"replication' \n@param partner - name of partner (corresponding to ReplicationPartner record)\n@param boClass - class of objects whose updates are sent to partner",
	"function": "function (db, queryParams, _, Q, httpRequestLib, nodeRequire, ReplicationService) {\n    var deferred = Q.defer();\n    var partnerName = queryParams.partner;\n    var boClass = queryParams.boClass;\n    \n    var VersionId = nodeRequire('../api/datasource/version_id');\n    \n    var partnerUrl;\n    var token;\n    \n    var QueryOpService = db._svc.QueryOpService; //for condition checking\n    \n    return db.ReplicationPartner.findOne({name:partnerName}).then(function(rp) {\n        \n      if(!rp) {\n            throw new Error('bad partner name');\n      }\n      \n      partnerUrl = rp.url;\n      token = rp.auth.token;\n      \n      return db.ReplicationSpec.findOne({partner:rp._id, business_object:db[boClass]._bo_meta_data.bod_id})\n    }) \n    .then(function(repSpec) {\n        \n      var specCondition = repSpec.condition;\n\n      var url = partnerUrl+'/ws/repsync/getManifest?boClass='+boClass;\n      var header = { authorization:'Bearer '+token};\n      \n      \n      console.log('Attempting HTTP GET of %s', url);\n      httpRequestLib.get( {\n          uri:url,\n          headers:header,\n          rejectUnauthorized: false,\n          json:true\n      }, function(err, httpResponse, body) {\n          if(body && body.result) {\n              \n              var manualMerges = [];\n              var partnerVersion = {}; //maps _id to __ver\n              \n              _.forEach(body.result, function(item){\n                  partnerVersion[item._id] = new VersionId(item.__ver);\n              });\n              \n              db[boClass].find({}).then(function(resultArr) {\n                    _.forEach(resultArr, function(localObj) {\n                        var id = localObj._id;\n                        var pv = partnerVersion[localObj._id];\n                        \n                        var lv = new VersionId(''+localObj.__ver);\n                        \n                        if(!pv) {\n                            //It's not in partner's manifest; send a create if condition passes\n                            // console.log('%s - NEW; version=%s', id, localObj.__ver);\n                            if(!specCondition || QueryOpService.satisfiesCondition(localObj, specCondition)) {\n                                return ReplicationService.enqueueEvent(localObj, 'create');\n                            }\n                            return;\n                        }\n                        \n                        //Compare versions...\n                        var localToPartner = lv.relationshipTo(pv);\n                        \n                        \n                        //Special cases: OLD records have object id's as __ver values\n                        var localNewer = !lv.isObjectId && pv.isObjectId;\n                        var partnerNewer = lv.isObjectId && !pv.isObjectId;\n                        var bothOld = lv.isObjectId && pv.isObjectId;\n                        \n                        \n                        if(partnerNewer || localToPartner.ancestor || localToPartner.same) {\n                            return;\n                        }\n                        \n                        \n                        if(localNewer || localToPartner.descendant) {\n                            //more recent changes local - send an update\n                            // console.log('%s - DESCENDANT', id);\n                            return ReplicationService.enqueueEvent(localObj, 'update');\n                        }\n                        \n                        if(bothOld || localToPartner.cousin) {\n                            //divergent changes\n                            // console.log('%s - COUSIN', id);\n                            ReplicationService.enqueueEvent(localObj, 'merge');\n                            return manualMerges.push({id:localObj._id, local:lv.toString(), remote:pv.toString()});\n                        }\n                        \n                        \n                    });\n                    \n                    //finished processing resultArr\n                    deferred.resolve({merges:manualMerges});\n                    \n              });\n              \n              \n              \n          }\n          else {\n              console.error('FAILED MANIFEST GET: %s, %j', err, body);\n              deferred.reject('failed manifest get')\n          }\n      });\n    \n    \n    return deferred.promise;\n    \n});\n    \n}",
	"path": "/repsync/performSync",
	"rolespec": [
		"waXPuuXVSEat6D7hXR0Nng"
	]
},
{
	"__disp": "/repsync/getManifest",
	"__ver": "sys-pkg:1",
	"_class": "WebService",
	"_id": "p1Hh0VyER7eLn1vfv5UFBQ",
	"doc": "returns list of id/version pairs for specified BO Class; used for inital sync with parther; the partner uses the list to determine what objects to send\n@param boClass",
	"function": "function (db, queryParams) {\n    var boClass = queryParams.boClass;\n    return db[boClass].find({},{__ver:1, _id:1}).then(function(resultArr) {\n        return {result:resultArr};\n    });\n}",
	"path": "/repsync/getManifest",
	"rolespec": [
		"waXPuuXVSEat6D7hXR0Nng"
	]
},
{
	"__disp": "/replication/attachment",
	"__ver": "sys-pkg:1",
	"_class": "WebService",
	"_id": "wW66tKohQdahn01dGX7PBA",
	"doc": "receives attachemnt from replication partner",
	"function": "function (db, req, queryParams, nodeRequire, Q) {\n    \n    const conf = nodeRequire('../conf');\n    \n    var metaObj;\n    try {\n        metaObj = JSON.parse(queryParams.metaObj);\n    }\n    catch(err) {\n        throw 'Bad metadata';\n    }\n    \n    // console.log(metaObj);\n    \n    \n    const multiparty = require('multiparty');\n    const form = new multiparty.Form({\n        autoFiles:false,\n        autoFields:false\n    });\n    \n    const deferred = Q.defer();\n    \n    form.on('error', function(err) {\n        console.error(err);\n        deferred.resolve({result:err.message});\n    });\n    \n    form.on('part', function(part) {\n        console.log('Processing upload part: %s', part.name);\n        if(part.name === 'fileStream') {\n            \n            const Grid = require('gridfs-stream');\n            var mongoose = require('mongoose');\n    \n            var conn = mongoose.createConnection(conf.mongo.uri, conf.mongo.options);\n            \n            conn.once('open', function () {\n                var gfs = Grid(conn.db, mongoose.mongo);\n                \n                var attachment = metaObj.attachment;\n                var gridMetadata = metaObj.metadata;\n                \n                var opts = {\n                    _id:attachment.attachment_id, \n                    metadata:gridMetadata\n                };\n                \n                gfs.findOne({filename:attachment.attachment_id}, function (err, file) {\n                    if(file) {\n                        console.log('already have file '+attachment.attachment_id);\n                        return conn.close();\n                    }\n                \n                    var ws = gfs.createWriteStream(opts);\n                    \n                    ws.on('finish', function() {\n                        console.log('SUCCESSFULLY SAVED ATTACHMENT');\n                        conn.close();\n                    });\n                    ws.on('error', function(err) {\n                        console.log('Failed to save attachment');\n                        console.log(err);\n                    });\n                    \n                    part.pipe(ws);\n                });\n            });\n            \n            \n        }\n        else {\n            console.error('unknown part');\n        }\n        \n    });\n    \n    form.on('close', function() {\n        deferred.resolve({result:'success'});\n    });\n\n    form.parse(req);\n    \n      \n    return deferred.promise;\n\n}",
	"path": "/replication/attachment",
	"rolespec": [
	]
}]}
